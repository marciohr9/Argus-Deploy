---
# Sub-tarefas por projeto (variável 'project' disponível)

# Caminho absoluto do compose
- name: Calcula caminho absoluto do compose
  ansible.builtin.set_fact:
    _compose_abs_path: >-
      {{
        (project.compose_path is search('^/'))
          | ternary(project.compose_path, project.dir ~ '/' ~ project.compose_path)
      }}

# Diretório do projeto
- name: Cria diretório do projeto
  ansible.builtin.file:
    path: "{{ project.dir }}"
    state: directory
    mode: "0755"

# Clone/Update (SSH)
- name: (SSH) Grava chave privada temporária quando fornecida inline
  when: project.auth_method == 'ssh' and project.ssh_key_inline | length > 0
  no_log: false
  ansible.builtin.copy:
    dest: "{{ project.dir }}/.git_ssh_key"
    content: "{{ project.ssh_key_inline }}"
    mode: "0600"

- name: (SSH) Clona/atualiza repositório
  when: project.auth_method == 'ssh'
  no_log: false
  ansible.builtin.git:
    repo: "{{ project.repo_url }}"
    dest: "{{ project.dir }}"
    key_file: >-
      {{
        (project.ssh_key_inline | length > 0)
          | ternary(project.dir ~ '/.git_ssh_key', project.ssh_key_path)
      }}
    version: "{{ project.version | default('HEAD') }}"
    accept_hostkey: true
    update: yes
    force: yes

# Clone/Update (HTTPS)
- name: (HTTPS) Clona/atualiza repositório
  when: project.auth_method == 'https'
  no_log: false
  ansible.builtin.git:
    repo: "{{ project.repo_url }}"
    dest: "{{ project.dir }}"
    version: "{{ project.version | default('HEAD') }}"
    update: yes
    force: yes

# docker-compose obrigatório
- name: Verifica existência do docker-compose no caminho informado
  ansible.builtin.stat:
    path: "{{ _compose_abs_path }}"
  register: _compose_stat

- name: Falha se docker-compose.yml não encontrado
  ansible.builtin.assert:
    that:
      - _compose_stat.stat.exists
    fail_msg: "Compose não encontrado em {{ _compose_abs_path }}"

### COPIANDO ARQUIVO ENV ###
# raiz do repo = diretório pai de playbook_dir (…/deploy-projetos)
- name: Define repo_root (um nível acima de playbooks)
  ansible.builtin.set_fact:
    _repo_root: "{{ playbook_dir | regex_replace('/[^/]+$', '') }}"

# Caminho base preferido para o env (relativo → raiz do repo)
- name: Calcula caminho preferencial do arquivo de env (relativo → repo_root)
  ansible.builtin.set_fact:
    _env_src_candidate: >-
      {{
        (
          project.env_src | default('./' ~ project.id ~ '.env')
        )
        | regex_replace('^\\./','')
      }}

# 1ª tentativa: repo_root/<env>
- name: Monta caminho absoluto em repo_root
  ansible.builtin.set_fact:
    _env_src_abs: "{{ _repo_root ~ '/' ~ _env_src_candidate }}"
  when: (project.env_src | default('')) is not match('^/')

# Se for absoluto, use como está
- name: Usa caminho absoluto informado em project.env_src
  ansible.builtin.set_fact:
    _env_src_abs: "{{ project.env_src }}"
  when: (project.env_src | default('')) is match('^/')

# Verifica existência no CONTROLADOR (não no host alvo)
- name: Verifica se o arquivo de env existe na localização preferida (controller)
  ansible.builtin.stat:
    path: "{{ _env_src_abs }}"
  register: _env_src_stat
  delegate_to: localhost
  run_once: true

# Fallback: se não existir em repo_root, tenta playbook_dir/<env>
- name: Aplica fallback para playbook_dir quando necessário
  when: not _env_src_stat.stat.exists
  ansible.builtin.set_fact:
    _env_src_abs: "{{ playbook_dir ~ '/' ~ _env_src_candidate }}"

# Checa novamente após fallback
- name: Verifica existência após fallback (controller)
  ansible.builtin.stat:
    path: "{{ _env_src_abs }}"
  register: _env_src_stat2
  delegate_to: localhost
  run_once: true

# Falha clara se não encontrou em nenhum lugar
- name: Falha se o arquivo de env não foi encontrado no controlador
  ansible.builtin.assert:
    that:
      - _env_src_stat2.stat.exists
      - _env_src_stat2.stat.isreg
    fail_msg: >-
      Arquivo de env não encontrado: {{ _env_src_abs }}.
      Defina "project.env_src" (ex.: ./{{ project.id }}.env) no nó CONTROLADOR.

# Copia o arquivo bruto do controlador para o host alvo como <dir>/.env
- name: Copia {{ _env_src_abs }} → {{ project.dir }}/.env (destino)
  ansible.builtin.copy:
    src: "{{ _env_src_abs }}"     # lido no controlador (padrão do módulo copy)
    dest: "{{ project.dir }}/.env"
    force: true
    backup: false

### ADICIONANDO NETWORK 'proxy' SE EXISTIR ###
# Patch da network 'proxy' (se existir)
- name: Carrega YAML do compose para variável (para patch)
  when: proxy_network_exists
  ansible.builtin.slurp:
    src: "{{ _compose_abs_path }}"
  register: _compose_slurp

- name: Converte YAML para dict
  when: proxy_network_exists
  ansible.builtin.set_fact:
    compose_data: "{{ _compose_slurp.content | b64decode | from_yaml }}"

- name: Aplica patch para usar a network externa '{{ proxy_network_name }}'
  when: proxy_network_exists
  ansible.builtin.include_tasks: patch_compose.yml

- name: Escreve compose atualizado (se houve patch)
  when: proxy_network_exists
  ansible.builtin.copy:
    dest: "{{ _compose_abs_path }}"
    content: "{{ compose_data | to_nice_yaml(indent=2) }}"
    mode: "0644"

# Build & Up com Compose v2
- name: Build das imagens do projeto
  community.docker.docker_compose_v2:
    project_src: "{{ project.dir }}"
    project_name: "{{ project.name }}"
    files:
      - "{{ project.compose_path }}"
    build: always

- name: Sobe o projeto (up -d)
  community.docker.docker_compose_v2:
    project_src: "{{ project.dir }}"
    project_name: "{{ project.name }}"
    files:
      - "{{ project.compose_path }}"
    state: present
    recreate: auto
    pull: missing

# Health-check
- name: Descobre nomes dos containers do projeto (via labels do compose)
  community.docker.docker_host_info:
    containers: true
    containers_filters:
      label:
        - "com.docker.compose.project={{ project.name }}"
        - "com.docker.compose.oneoff!=True"
  register: _host_info

- name: Lista nomes dos containers do projeto atual
  ansible.builtin.set_fact:
    _project_container_names: >-
      {{
        _host_info.containers
        | map(attribute='Name')
        | map('regex_replace','^/','')
        | list
      }}

- name: Espera cada container ficar running/healthy
  community.docker.docker_container_info:
    name: "{{ item }}"
  register: _ci
  until: >
    (_ci.container.State.Status == 'running') and
    (
      (_ci.container.State.Health is not defined) or
      (_ci.container.State.Health.Status == 'healthy')
    )
  retries: "{{ (health_timeout_seconds // 5) | int }}"
  delay: 5
  loop: "{{ _project_container_names }}"
  loop_control:
    label: "{{ item }}"

# - name: Falha se nenhum container foi encontrado para o projeto
#   ansible.builtin.assert:
#     that:
#       - _project_container_names | length > 0
#     fail_msg: "Nenhum container do projeto '{{ project.name }}' foi encontrado após o deploy."
