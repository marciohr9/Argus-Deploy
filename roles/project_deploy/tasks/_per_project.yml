---
# Sub-tarefas por projeto (variável 'project' disponível)

# Caminho absoluto do compose
- name: Calcula caminho absoluto do compose
  ansible.builtin.set_fact:
    _compose_abs_path: >-
      {{
        (project.compose_path is search('^/'))
          | ternary(project.compose_path, project.dir ~ '/' ~ project.compose_path)
      }}

# Diretório do projeto
- name: Cria diretório do projeto
  ansible.builtin.file:
    path: "{{ project.dir }}"
    state: directory
    mode: "0755"

# Normaliza para HTTPS (caso repo_url venha como SSH)
- name: Converte repo_url para HTTPS (se vier em formato SSH)
  ansible.builtin.set_fact:
    _repo_url_https: >-
      {{
        project.repo_url
        | regex_replace('^ssh://git@github\\.com/(.*)$', 'https://github.com/\\1')
        | regex_replace('^git@github\\.com:(.*)$',         'https://github.com/\\1')
      }}

# Injeta token na URL
- name: Monta URL autenticada com token
  no_log: false
  ansible.builtin.set_fact:
    _repo_url_auth: >-
      {{
        _repo_url_https
        | regex_replace('^https://', 'https://x-access-token:' ~ (github_token | urlencode) ~ '@')
      }}

# Clone/Update com token via HTTPS
- name: Clona/atualiza repositório (HTTPS + token)
  no_log: false
  ansible.builtin.git:
    repo: "{{ _repo_url_auth }}"
    dest: "{{ project.dir }}"
    version: "{{ project.version | default('HEAD') }}"
    update: yes
    force: yes
    accept_hostkey: true

# Remove o token da URL remota
- name: Remove token da origem (.git/config) substituindo pela URL sem credenciais
  no_log: true
  ansible.builtin.command: >
    git remote set-url origin {{ _repo_url_https }}
  args:
    chdir: "{{ project.dir }}"
  changed_when: true

# docker-compose obrigatório
- name: Verifica existência do docker-compose no caminho informado
  ansible.builtin.stat:
    path: "{{ _compose_abs_path }}"
  register: _compose_stat

- name: Falha se docker-compose.yml não encontrado
  ansible.builtin.assert:
    that:
      - _compose_stat.stat.exists
    fail_msg: "Compose não encontrado em {{ _compose_abs_path }}"

### COPIANDO ARQUIVO ENV ###
# raiz do repo = diretório pai de playbook_dir (…/deploy-projetos)
- name: Define repo_root (um nível acima de playbooks)
  ansible.builtin.set_fact:
    _repo_root: "{{ playbook_dir | regex_replace('/[^/]+$', '') }}"

# Caminho base preferido para o env (relativo → raiz do repo)
# (sem delegate_to: queremos a var gravada no host alvo)
- name: Calcula caminho preferencial do arquivo de env (relativo → repo_root)
  ansible.builtin.set_fact:
    _env_src_candidate: >-
      {{
        (project.env_src | default('./' ~ project.id ~ '.env'))
        | regex_replace('^\\./','')
      }}

# 1ª tentativa: repo_root/<env>
- name: Monta caminho absoluto em repo_root
  ansible.builtin.set_fact:
    _env_src_abs: "{{ _repo_root ~ '/' ~ _env_src_candidate }}"
  when: (project.env_src | default('')) is not match('^/')

# Se for absoluto, use como está
- name: Usa caminho absoluto informado em project.env_src
  ansible.builtin.set_fact:
    _env_src_abs: "{{ project.env_src }}"
  when: (project.env_src | default('')) is match('^/')

# Verifica existência no CONTROLADOR (não no host alvo)
- name: Verifica se o arquivo de env existe na localização preferida (controller)
  ansible.builtin.stat:
    path: "{{ _env_src_abs }}"
  register: _env_src_stat
  delegate_to: localhost
  become: false

# Fallback: se não existir em repo_root, tenta playbook_dir/<env>
- name: Aplica fallback para playbook_dir quando necessário
  when: not _env_src_stat.stat.exists
  ansible.builtin.set_fact:
    _env_src_abs: "{{ playbook_dir ~ '/' ~ _env_src_candidate }}"

# Checa novamente após fallback (no controlador)
- name: Verifica existência após fallback (controller)
  ansible.builtin.stat:
    path: "{{ _env_src_abs }}"
  register: _env_src_stat2
  delegate_to: localhost
  become: false

# Falha clara se não encontrou em nenhum lugar
- name: Falha se o arquivo de env não foi encontrado no controlador
  ansible.builtin.assert:
    that:
      - _env_src_stat2.stat.exists
      - _env_src_stat2.stat.isreg
    fail_msg: >-
      Arquivo de env não encontrado: {{ _env_src_abs }}.
      Defina "project.env_src" (ex.: ./{{ project.id }}.env) no nó CONTROLADOR.

# Copia o arquivo bruto do controlador para o host alvo como <dir>/.env
- name: Copia {{ _env_src_abs }} → {{ project.dir }}/.env (destino)
  ansible.builtin.copy:
    src: "{{ _env_src_abs }}"   # lido no controlador (default do copy)
    dest: "{{ project.dir }}/.env"
    force: true
    backup: false

### ADICIONANDO NETWORK 'proxy' SE EXISTIR ###
# Patch da network 'proxy' (se existir)
- name: Carrega YAML do compose para variável (para patch)
  when: proxy_network_exists
  ansible.builtin.slurp:
    src: "{{ _compose_abs_path }}"
  register: _compose_slurp

- name: Converte YAML para dict
  when: proxy_network_exists
  ansible.builtin.set_fact:
    compose_data: "{{ _compose_slurp.content | b64decode | from_yaml }}"

- name: Aplica patch para usar a network externa '{{ proxy_network_name }}'
  when: proxy_network_exists
  ansible.builtin.include_tasks: patch_compose.yml

- name: Escreve compose atualizado (se houve patch)
  when: proxy_network_exists
  ansible.builtin.copy:
    dest: "{{ _compose_abs_path }}"
    content: "{{ compose_data | to_nice_yaml(indent=2) }}"
    mode: "0644"
## BUILD de IMAGEM E DEPLOY ##
#Remove containers do mesmo projeto (labels do compose)
- name: Descobre containers existentes do projeto (labels)
  community.docker.docker_host_info:
    containers: true
    containers_filters:
      label:
        - "com.docker.compose.project={{ project.name }}"
        - "com.docker.compose.oneoff!=True"
  register: _existing_by_label

- name: Remove containers existentes do projeto (kill + rm)
  when: (_existing_by_label.containers | default([])) | length > 0
  community.docker.docker_container:
    name: "{{ item.Name | regex_replace('^/','') }}"
    state: absent
    force_kill: true
    keep_volumes: true
  loop: "{{ _existing_by_label.containers }}"
  loop_control:
    label: "{{ item.Name | regex_replace('^/','') }}"

# Se houver container_name explícito no compose, remova conflitos por nome (isso cobre casos fora do compose do projeto ou leftovers sem label)
- name: Carrega compose para extrair container_name (se ainda não carregado)
  when: compose_data is not defined
  ansible.builtin.slurp:
    src: "{{ _compose_abs_path }}"
  register: _compose_slurp_for_names

- name: Converte YAML para dict (se ainda não carregado)
  when: compose_data is not defined
  ansible.builtin.set_fact:
    compose_data: "{{ _compose_slurp_for_names.content | b64decode | from_yaml }}"

- name: Lista container_name explícitos no compose
  ansible.builtin.set_fact:
    _explicit_container_names: >-
      {{
        (compose_data.services | default({}))
        | dict2items
        | map(attribute='value.container_name')
        | select('defined')
        | list
      }}

- name: Coleta info de containers com nomes explícitos (se existirem)
  when: (_explicit_container_names | length) > 0
  community.docker.docker_container_info:
    name: "{{ item }}"
  loop: "{{ _explicit_container_names }}"
  register: _ci_named
  failed_when: false
  changed_when: false

- name: Remove containers com nomes explícitos que existam
  when: (_ci_named.results | selectattr('container','defined') | list | length) > 0
  community.docker.docker_container:
    name: "{{ item.container.Name | regex_replace('^/','') }}"
    state: absent
    force_kill: true
    keep_volumes: true
  loop: "{{ _ci_named.results | selectattr('container','defined') | list }}"
  loop_control:
    label: "{{ item.container.Name | regex_replace('^/','') }}"

# Build & Up com Compose v2
- name: Build das imagens do projeto
  community.docker.docker_compose_v2:
    project_src: "{{ project.dir }}"
    project_name: "{{ project.name }}"
    files:
      - "{{ project.compose_path }}"
    build: always

- name: Sobe o projeto (up -d)
  community.docker.docker_compose_v2:
    project_src: "{{ project.dir }}"
    project_name: "{{ project.name }}"
    files:
      - "{{ project.compose_path }}"
    state: present
    recreate: auto
    pull: missing

# Health-check
- name: Descobre nomes dos containers do projeto (via labels do compose)
  community.docker.docker_host_info:
    containers: true
    containers_filters:
      label:
        - "com.docker.compose.project={{ project.name }}"
        - "com.docker.compose.oneoff!=True"
  register: _host_info

- name: Lista nomes dos containers do projeto atual
  ansible.builtin.set_fact:
    _project_container_names: >-
      {{
        _host_info.containers
        | map(attribute='Name')
        | map('regex_replace','^/','')
        | list
      }}

- name: Espera cada container ficar running/healthy
  community.docker.docker_container_info:
    name: "{{ item }}"
  register: _ci
  until: >
    (_ci.container.State.Status == 'running') and
    (
      (_ci.container.State.Health is not defined) or
      (_ci.container.State.Health.Status == 'healthy')
    )
  retries: "{{ (health_timeout_seconds // 5) | int }}"
  delay: 5
  loop: "{{ _project_container_names }}"
  loop_control:
    label: "{{ item }}"

# - name: Falha se nenhum container foi encontrado para o projeto
#   ansible.builtin.assert:
#     that:
#       - _project_container_names | length > 0
#     fail_msg: "Nenhum container do projeto '{{ project.name }}' foi encontrado após o deploy."
